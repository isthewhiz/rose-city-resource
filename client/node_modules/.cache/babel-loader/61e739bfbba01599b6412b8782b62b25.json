{"ast":null,"code":"import { findDistance, inOutLocation } from \"./distance\";\nimport fetch from \"node-fetch\"; // ASYNC DATA UTLS--------------------------------------------------------\n//async function to fetch revision history\n//based on rose-city-resource\n\nexport async function getPackageData() {\n  ///new logic\n  const uri = \"/api/package\";\n  const packageData = await fetch(uri).catch(handleError).then(response => response.json());\n  return packageData;\n} //async fucntion to get data from node and add in phone records\n\nexport async function getNodeData() {\n  try {\n    const uri = \"/api/listings-resource\";\n    const listingsResponse = await fetch(uri);\n    const listingsJson = await listingsResponse.json();\n    const listingsData = await listingsJson.result.records; //get the NODE phone table\n\n    const phoneData = await getPhoneData(); //add the distance info here\n\n    let currentCoords;\n    const position = await inOutLocation().catch(e => console.log(\"Error getting position: \", e));\n\n    if (position !== undefined) {\n      currentCoords = [position.coords.latitude, position.coords.longitude];\n    } else {\n      currentCoords = null;\n    } //get the user's location\n\n\n    const listingsDataPhoneData = phonePositionJoiner(listingsData, phoneData, currentCoords);\n    return listingsDataPhoneData;\n  } catch (err) {\n    console.log(err);\n  }\n} //async funtion to get phone data\n//which will then be joined to nodeData\n\nexport async function getPhoneData() {\n  try {\n    const uri = \"/api/phone-resource\";\n    const phoneResponse = await fetch(uri);\n    const phoneJson = await phoneResponse.json();\n    const phoneData = await phoneJson.result.records;\n    return phoneData;\n  } catch (err) {\n    console.log(err);\n  }\n} // SYNC DATA UTILS-----------------------------------------------------------------\n//funtion to create a data string based\n//on UTC string returned from package data\n\nexport function dateString(utcString) {\n  return utcString.split(\"T\")[0];\n} //sync funtion that returns filtered node data using\n//values from any of the search options (listing, parent_org, main_category)\n//this function uses helper functions\n\nexport function getNodeFilteredData(searchVals, categoryVals, parentVals, nodeData) {\n  //if the searchVal is undefined then\n  //do this\n  if (searchVals === undefined) {\n    const filteredNodeData = getFilteredCatParentData(categoryVals, parentVals, nodeData);\n    return filteredNodeData;\n  } else {\n    const filteredNodeData = getFilteredSearchData(searchVals, nodeData);\n    return filteredNodeData;\n  }\n} //this also may not be used\n\nexport function getFilteredSearchList(searchCats, nodeData) {\n  const filteredValsList = nodeData.map(record => {\n    return searchCats.map(cat => record[cat]);\n  });\n  const catList = [].concat(...filteredValsList);\n  return [...new Set(catList)].sort();\n} //functions to set up category search data\n\nexport function getCategorySearchData(nodeData, category) {\n  const genCats = nodeData.map(record => {\n    const generalRecord = record[category];\n    return generalRecord;\n  });\n  const filteredGenCats = genCats.filter(cat => cat !== \"NA\");\n  return countDuplicates(filteredGenCats);\n}\nexport function getMainSearchData(nodeData) {\n  // these will eventually need to be added in dynamically\n  const genCats = [\"Food\", \"Housing & Shelter\", \"Goods\", \"Transit\", \"Health & Wellness\", \"Money\", \"Care & Safety\", \"Work\", \"Legal\", \"Day Services\", \"Specialized Assistance\"];\n  const mainCats = genCats.map((cat, i) => {\n    const filterCats = nodeData.filter(record => record.general_category === cat);\n    return filterCats;\n  });\n  const mainCatsCount = mainCats.map((cat, i) => {\n    const catVals = cat.map(c => {\n      return c[\"main_category\"];\n    });\n    return countDuplicates(catVals);\n  });\n  const mainCategory = genCats.reduce((o, k, i) => ({ ...o,\n    [k]: mainCatsCount[i]\n  }), {});\n  return mainCategory;\n} //function to return phone records obejct in\n//a card taking into account NA\n\nexport function cardPhoneTextFilter(record) {\n  if (record.phone.length > 0) {\n    const cleanPhone = record.phone.map(phoneRecord => {\n      const phone1 = phoneRecord.phone;\n      const phone2 = naRemove(phoneRecord.phone2); //return the new object\n\n      return {\n        type: phoneRecord.type,\n        phone: phone1 + phone2\n      };\n    });\n    return cleanPhone;\n  } else {\n    return null;\n  }\n}\nexport function cardTextFilter(recordKey) {\n  return naRemove(recordKey).trim();\n}\nexport function cardWebAddressFixer(webAddress) {\n  // if(address.indexOf(\"http\") > 0)\n  const webAddressFilter = cardTextFilter(webAddress);\n\n  if (webAddress.indexOf(\"http\") < 0 && webAddressFilter !== \"\") {\n    return `http://${webAddressFilter}`;\n  }\n\n  return webAddressFilter;\n} //function to build the map data object\n\nexport function mapDataBuilder(nodeData) {\n  const mapData = nodeData.map(record => {\n    if (record.lat !== \"NA\") {\n      const coords = [Number(record.lat), Number(record.lon)];\n      const {\n        listing,\n        street,\n        street2,\n        hours,\n        id\n      } = record;\n      return {\n        coords,\n        popup: {\n          listing,\n          street,\n          street2: cardTextFilter(street2),\n          hours: cardTextFilter(hours),\n          id\n        }\n      };\n    }\n  });\n  const mapDataFilter = mapData.filter(el => el !== undefined);\n  const latArr = mapDataFilter.map(item => item.coords[0]);\n  const lonArr = mapDataFilter.map(item => item.coords[1]); //now use the getCenter() helper function\n\n  const center = getCenter(latArr, lonArr, [45.52345, -122.6762]);\n  return {\n    mapData: mapDataFilter,\n    center\n  };\n}\nexport function cardDetailsFilter(nodeData, savedIds) {\n  function exists(rec) {\n    return savedIds.indexOf(rec.id) > -1;\n  }\n\n  const filteredDetailsData = nodeData.filter(exists);\n  return filteredDetailsData;\n} // NON-EXPORTED HELPER UTILS-------------------------------------------------------\n//helper function for buildings the direction string\n\nfunction stringBuilder(str) {\n  return str.split(\" \").join(\"+\");\n} //helper function to build directions for google\n\n\nexport function directionsUrlBuilder(street, city, postal_code) {\n  if (street !== \"NA\") {\n    return `/${stringBuilder(street)}+${stringBuilder(city)}+${stringBuilder(postal_code)}`;\n  } else {\n    return \"NA\";\n  }\n} //helper function to get the center of a map\n//use this in the mapDatabuilder function\n\nfunction getCenter(latArr, lonArr, defaultArr) {\n  const average = arr => arr.reduce((p, c) => p + c, 0) / arr.length;\n\n  const lat = average(latArr);\n  const lon = average(lonArr);\n  if (isNaN(lat)) return defaultArr;\n  return [lat, lon];\n} //check if parent or category vals in records\n//helper for getFilteredNodeData\n\n\nfunction getFilteredCatParentData(categoryVals, parentVals, nodeData) {\n  const checkVals = [// ...handleArray(searchVals),\n  ...handleArray(categoryVals), ...handleArray(parentVals)].filter(el => el !== null);\n  const filteredNodeData = nodeData.filter(record => {\n    //create another array to see if checkVals are in\n    //the nodeVals\n    const nodeVals = [record.listing, record.parent_organization, record.main_category, record.general_category]; //check to see if any values in one array are in the other array\n    //and if so return the record\n\n    if (nodeVals.some(item => checkVals.indexOf(item) >= 0)) {\n      record.directionsUrl = directionsUrlBuilder(record.street, record.city, record.postal_code);\n      return record;\n    } else {\n      return null;\n    }\n  }); //filter out the nulls\n\n  return filteredNodeData.filter(el => el !== null);\n} //check if a search value is in the NODE record\n//this function is gonna be used for individual searches\n//helper for getFilteredNodeData\n\n\nfunction getFilteredSearchData(searchValue, nodeData) {\n  //Polyfill from SO to use toLowerCase()\n  if (!String.toLowerCase) {\n    String.toLowerCase = function (s) {\n      return String(s).toLowerCase();\n    };\n  }\n\n  const filterData = nodeData.map(record => {\n    const recordValsLower = Object.values(record).map(val => {\n      return String(val).toLowerCase();\n    } //I miss R\n    );\n\n    if (recordValsLower.join(\" \").includes(String(searchValue).toLowerCase())) {\n      record.directionsUrl = directionsUrlBuilder(record.street, record.city, record.postal_code);\n      return record;\n    }\n  }); // remove the undefined els from the list\n\n  return filterData.filter(el => el);\n} //function to deal with 'NA' values\n//and return an empty string instead\n\n\nfunction naRemove(str) {\n  if (str === \"NA\") return \"\";\n  return \" \" + str;\n} //function to join the phone data to the nodeData based on id\n\n\nfunction phonePositionJoiner(nodeData, phoneData, currentCoords) {\n  const nodePhoneData = nodeData.map(listRecord => {\n    //filter out the phone records that relate to the nodeRecord\n    const phoneKeep = phoneData.filter(phoneRecord => {\n      return phoneRecord.id === listRecord.id;\n    }); //calculate the distance here\n\n    const listCoords = [Number(listRecord.lat), Number(listRecord.lon)];\n    let distance; //handle whether an array was returned\n\n    if (Array.isArray(currentCoords)) {\n      distance = findDistance(currentCoords, listCoords);\n    } else {\n      distance = null;\n    }\n\n    return Object.assign(listRecord, {\n      phone: phoneKeep,\n      distance: distance\n    });\n  });\n  return nodePhoneData;\n} //count the duplicates in an array and\n//retrun an obect with the value and count\n\n\nfunction countDuplicates(arr) {\n  const map = arr.reduce(function (prev, cur) {\n    prev[cur] = (prev[cur] || 0) + 1;\n    return prev;\n  }, {});\n  return map;\n} //helper function to deal with the\n//parsing of query string\n\n\nfunction handleArray(item) {\n  if (item === undefined) return [null];\n  if (Array.isArray(item)) return item;\n  if (typeof item === \"string\") return [item];\n} //for async errors\n//this can be more expressive\n\n\nfunction handleError(error) {\n  console.warn(\"Something went wrong with a fetch.\", error);\n  return null;\n} // EXPORTED HELPER UTILS ----------------------------------------------\n//function to generate query\n//for detaisl page\n\n\nexport function detailsQueryBuilder(savedIds) {\n  // if(savedIds.length===0){\n  //   alert('No saved listings.')\n  // }\n  const queryDetailString = savedIds.join(\"&saved=\");\n  return `saved=${queryDetailString}`;\n} //get the object keys based on value\n\nexport function objectKeyByValue(obj, val) {\n  return Object.entries(obj).find(i => i[1] === val);\n} //make a query builder that will be passed to react router\n//parameter expect an array\n\nexport function queryBuilder(categoryVals, parentVals) {\n  let categoryString = \"\";\n  let parentString = \"\";\n\n  for (let i = 0; i < categoryVals.length; i++) {\n    categoryString += `category=${encodeURIComponent(categoryVals[i])}&`;\n  }\n\n  for (let i = 0; i < parentVals.length; i++) {\n    parentString += `parent=${encodeURIComponent(parentVals[i])}&`;\n  }\n\n  const queryString = `?${categoryString}${parentString}`;\n  return queryString;\n} //sort the cards based on the retirned distance\n\nexport function cardSortByDistance(data) {\n  function compare(a, b) {\n    a = a[\"distance\"];\n    b = b[\"distance\"];\n\n    if (isFinite(a - b)) {\n      return a - b;\n    } else {\n      return isFinite(a) ? -1 : 1; // switch these to retrun NaN at top\n    }\n  }\n\n  return data.sort(compare);\n} // --------------------------------------------------------------------------\n// ----------------------------------------------------------------------------\n// --END USED FUNCTION UTILS----------------------------------------------------\n//UNUSED ASYNC DATA UTILS--------------------------------------------------------\n//fetching utils\n// export async function getSearchData(searchCats) {\n//   const searchList = searchCats.join(\" ,\");\n//   const uri = `https://opendata.imspdx.org/api/3/action/datastore_search_sql?sql=SELECT ${searchList} from \"${listingResource}\"`;\n//   const searchData = await fetch(uri)\n//     .then((response) => response.json())\n//     .then((json) => json.result.records)\n//     .catch(handleError);\n//   const filteredValsList = searchData.map((record) => {\n//     return searchCats.map((cat) => record[cat]);\n//   });\n//   const catList = [].concat(...filteredValsList);\n//   return [...new Set(catList)].sort();\n// }\n// //\n// export async function getSelectedCategories(navCategory, selectedItem) {\n//   if (selectedItem === null) {\n//     const dataResponse = await fetch(\n//       `https://opendata.imspdx.org/api/3/action/datastore_search_sql?sql=SELECT general_category from \"${listingResource}\"`\n//     ).catch(handleError);\n//     const jsonDataArr = await dataResponse\n//       .json()\n//       .then((json) => json.result.records)\n//       .then((records) => {\n//         return records.map((record) => Object.values(record));\n//       });\n//     const jsonDataCount = await countDuplicates(jsonDataArr);\n//     // console.log('jsonDataCount', jsonDataCount);\n//     return jsonDataCount;\n//   } else {\n//     const cleanSelectedItem = selectedItem.replace(\"&\", \"%26\");\n//     const uri = `https://opendata.imspdx.org/api/3/action/datastore_search_sql?sql=SELECT main_category from \"${listingResource}\" WHERE ${navCategory} LIKE '${cleanSelectedItem}'`;\n//     const dataResponse = await fetch(uri).catch(handleError);\n//     const jsonDataArr = await dataResponse\n//       .json()\n//       .then((json) => json.result.records)\n//       .then((records) => {\n//         return records.map((record) => Object.values(record));\n//       });\n//     const jsonDataCount = await countDuplicates(jsonDataArr);\n//     return jsonDataCount;\n//   }\n// }\n// //build the query from results of search\n// //include helper functions which are below\n// export async function nodeQueryBuilder(catVals, parentVals, searchVals = []) {\n//   //return a null is both values are undefined\n//   //this can likely be handled in the adv search\n//   if (catVals === undefined && parentVals === undefined) {\n//     return null;\n//   } else {\n//     const categoryString = queryStringBuilder(catVals, \"main\");\n//     const parentString = queryStringBuilder(parentVals, \"parent\");\n//     //put the URI together, this can be further split\n//     const uri = `https://opendata.imspdx.org/api/3/action/datastore_search_sql?sql=SELECT * from \"${listingResource}\" WHERE ${categoryString} OR ${parentString}`;\n//     const response = await fetch(uri).catch(handleError);\n//     const jsonDataArr = await response\n//       .json()\n//       .then((json) => json.result.records)\n//       .then((records) => records);\n//     return jsonDataArr;\n//   }\n// }\n// UNUSED SYNC DATA UTILS ------------------------------------------------\n//////data utils for switching categories\n// export function categoryFwdSwitcher(category) {\n//   if (category === \"general_category\") {\n//     return \"main_category\";\n//   }\n// }\n// export function categoryBackSwitcher(category) {\n//   if (category === \"main_category\") {\n//     return \"general_category\";\n//   }\n//   if (category === \"general_category\") {\n//     return null;\n//   }\n// }\n// UNUSED HELPER UTILS-----------------------------------------------------------\n//helper function\n//build the string while expecting an array\n//deal with category type and\n// function queryStringBuilder(arrItem, category) {\n//   //sanitize the arrItem\n//   const arr = handleArray(arrItem);\n//   if (category === \"main\") {\n//     if (arr !== null) {\n//       const categoryString = arr\n//         .map((val) => {\n//           const encodeUri = encodeURIComponent(val);\n//           return `'${encodeUri}'`;\n//         })\n//         .join(\"OR main_category LIKE \");\n//       return `main_category LIKE ${categoryString}`;\n//     } else {\n//       return null;\n//     }\n//   }\n//   if (category === \"parent\") {\n//     if (arr !== null) {\n//       const parentString = arr\n//         .map((val) => {\n//           const encodeUri = encodeURIComponent(val);\n//           return `'${encodeUri}'`;\n//         })\n//         .join(\"OR parent_organization LIKE \");\n//       return `parent_organization LIKE ${parentString}`;\n//     }\n//     return null;\n//   }\n// }\n// UNUSED PROP TYPE UTILS---------------------------------------------------\n//prop-types helpers\n// export function conditionalPropType(condition, message) {\n//   if (typeof condition !== \"function\")\n//     throw \"Wrong argument type 'condition' supplied to 'conditionalPropType'\";\n//   return function (props, propName, componentName) {\n//     if (condition(props, propName, componentName)) {\n//       return new Error(\n//         `Invalid prop '${propName}' '${props[propName]}' supplied to '${componentName}'. ${message}`\n//       );\n//     }\n//   };\n// }\n//More async funtions that interact with NODE\n// export async function getCategoryList(navCategory) {\n//   const uri = `https://opendata.imspdx.org/api/3/action/datastore_search_sql?sql=SELECT  from \"${listingResource}\" WHERE 'main_category' LIKE ${navCategory}`;\n//   const categories = await fetch(uri);\n//   return categories;\n// }\n////////////////////////////////////////////////////IN DEV\n// export async function getSearchList(searchCats) {\n//   //if needed in dev, here is a proxy\n//   const proxy = 'https://cors-anywhere.herokuapp.com/';\n//   //categories to include in the initial searching\n//   const searchCatsUri = searchCats.join(', ');\n//   const uri = `https://opendata.imspdx.org/api/3/action/datastore_search_sql?sql=SELECT ${searchCatsUri} from \"${listingResource}\"`;\n//   const searchData = await fetch(uri)\n//     .then(response => response.json())\n//     .then(json => json.result.records)\n//     //select out the values only\n//     .then(records => {\n//       return records.map(record => Object.values(record));\n//     })\n//     //concatenate lists and filter duplicates\n//     .then(lists => {\n//       const catList = [].concat.apply([], lists);\n//       return [...new Set(catList)].sort();\n//     });\n//   //return the final filtered list\n//   return searchData;\n// }\n///////////////////////////////////////////\n// return a list with full NODE data and filtered list for search bar\n// export async function getFilteredSearchList(searchCats) {\n//   let nodeData;\n//   const searchData = await getNodeData()\n//     .then(json => {\n//       nodeData = json.result.records;\n//       return nodeData;\n//     })\n//     .then(records => {\n//       const filteredValsList = records.map(record => {\n//         return searchCats.map(cat => record[cat]);\n//       });\n//       return filteredValsList;\n//     })\n//     .then(searchList => {\n//       const catList = [].concat(...searchList);\n//       return [...new Set(catList)].sort();\n//     });\n//   return [nodeData, searchData];\n// }\n/////////////////////////////////\n// export function getCategorySearchData(nodeData) {\n//   const categories = nodeData.map(record => {\n//     const generalVal = record['general_category'];\n//     const mainVal = record['main_category'];\n//     return { generalVal, mainVal };\n//   });\n//   return categories;\n// }","map":{"version":3,"sources":["/home/isnardo/rcr/rose-city-resource/client/src/utils/api.js"],"names":["findDistance","inOutLocation","fetch","getPackageData","uri","packageData","catch","handleError","then","response","json","getNodeData","listingsResponse","listingsJson","listingsData","result","records","phoneData","getPhoneData","currentCoords","position","e","console","log","undefined","coords","latitude","longitude","listingsDataPhoneData","phonePositionJoiner","err","phoneResponse","phoneJson","dateString","utcString","split","getNodeFilteredData","searchVals","categoryVals","parentVals","nodeData","filteredNodeData","getFilteredCatParentData","getFilteredSearchData","getFilteredSearchList","searchCats","filteredValsList","map","record","cat","catList","concat","Set","sort","getCategorySearchData","category","genCats","generalRecord","filteredGenCats","filter","countDuplicates","getMainSearchData","mainCats","i","filterCats","general_category","mainCatsCount","catVals","c","mainCategory","reduce","o","k","cardPhoneTextFilter","phone","length","cleanPhone","phoneRecord","phone1","phone2","naRemove","type","cardTextFilter","recordKey","trim","cardWebAddressFixer","webAddress","webAddressFilter","indexOf","mapDataBuilder","mapData","lat","Number","lon","listing","street","street2","hours","id","popup","mapDataFilter","el","latArr","item","lonArr","center","getCenter","cardDetailsFilter","savedIds","exists","rec","filteredDetailsData","stringBuilder","str","join","directionsUrlBuilder","city","postal_code","defaultArr","average","arr","p","isNaN","checkVals","handleArray","nodeVals","parent_organization","main_category","some","directionsUrl","searchValue","String","toLowerCase","s","filterData","recordValsLower","Object","values","val","includes","nodePhoneData","listRecord","phoneKeep","listCoords","distance","Array","isArray","assign","prev","cur","error","warn","detailsQueryBuilder","queryDetailString","objectKeyByValue","obj","entries","find","queryBuilder","categoryString","parentString","encodeURIComponent","queryString","cardSortByDistance","data","compare","a","b","isFinite"],"mappings":"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CA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA","sourcesContent":["import { findDistance, inOutLocation } from \"./distance\";\nimport fetch from \"node-fetch\";\n\n// ASYNC DATA UTLS--------------------------------------------------------\n//async function to fetch revision history\n//based on rose-city-resource\nexport async function getPackageData() {\n  ///new logic\n  const uri = \"/api/package\";\n  const packageData = await fetch(uri)\n    .catch(handleError)\n    .then((response) => response.json());\n  return packageData;\n}\n\n//async fucntion to get data from node and add in phone records\nexport async function getNodeData() {\n  try {\n    const uri = \"/api/listings-resource\";\n    const listingsResponse = await fetch(uri);\n    const listingsJson = await listingsResponse.json();\n    const listingsData = await listingsJson.result.records;\n\n    //get the NODE phone table\n    const phoneData = await getPhoneData();\n\n    //add the distance info here\n    let currentCoords;\n    const position = await inOutLocation().catch((e) =>\n      console.log(\"Error getting position: \", e)\n    );\n\n    if (position !== undefined) {\n      currentCoords = [position.coords.latitude, position.coords.longitude];\n    } else {\n      currentCoords = null;\n    }\n\n    //get the user's location\n    const listingsDataPhoneData = phonePositionJoiner(\n      listingsData,\n      phoneData,\n      currentCoords\n    );\n\n    return listingsDataPhoneData;\n  } catch (err) {\n    console.log(err);\n  }\n}\n\n//async funtion to get phone data\n//which will then be joined to nodeData\nexport async function getPhoneData() {\n  try {\n    const uri = \"/api/phone-resource\";\n    const phoneResponse = await fetch(uri);\n    const phoneJson = await phoneResponse.json();\n    const phoneData = await phoneJson.result.records;\n\n    return phoneData;\n  } catch (err) {\n    console.log(err);\n  }\n}\n\n// SYNC DATA UTILS-----------------------------------------------------------------\n\n//funtion to create a data string based\n//on UTC string returned from package data\nexport function dateString(utcString) {\n  return utcString.split(\"T\")[0];\n}\n//sync funtion that returns filtered node data using\n//values from any of the search options (listing, parent_org, main_category)\n//this function uses helper functions\nexport function getNodeFilteredData(\n  searchVals,\n  categoryVals,\n  parentVals,\n  nodeData\n) {\n  //if the searchVal is undefined then\n  //do this\n  if (searchVals === undefined) {\n    const filteredNodeData = getFilteredCatParentData(\n      categoryVals,\n      parentVals,\n      nodeData\n    );\n    return filteredNodeData;\n  } else {\n    const filteredNodeData = getFilteredSearchData(searchVals, nodeData);\n    return filteredNodeData;\n  }\n}\n\n//this also may not be used\nexport function getFilteredSearchList(searchCats, nodeData) {\n  const filteredValsList = nodeData.map((record) => {\n    return searchCats.map((cat) => record[cat]);\n  });\n  const catList = [].concat(...filteredValsList);\n  return [...new Set(catList)].sort();\n}\n\n//functions to set up category search data\nexport function getCategorySearchData(nodeData, category) {\n  const genCats = nodeData.map((record) => {\n    const generalRecord = record[category];\n    return generalRecord;\n  });\n  const filteredGenCats = genCats.filter((cat) => cat !== \"NA\");\n\n  return countDuplicates(filteredGenCats);\n}\n\nexport function getMainSearchData(nodeData) {\n  // these will eventually need to be added in dynamically\n  const genCats = [\n    \"Food\",\n    \"Housing & Shelter\",\n    \"Goods\",\n    \"Transit\",\n    \"Health & Wellness\",\n    \"Money\",\n    \"Care & Safety\",\n    \"Work\",\n    \"Legal\",\n    \"Day Services\",\n    \"Specialized Assistance\",\n  ];\n\n  const mainCats = genCats.map((cat, i) => {\n    const filterCats = nodeData.filter(\n      (record) => record.general_category === cat\n    );\n    return filterCats;\n  });\n\n  const mainCatsCount = mainCats.map((cat, i) => {\n    const catVals = cat.map((c) => {\n      return c[\"main_category\"];\n    });\n    return countDuplicates(catVals);\n  });\n\n  const mainCategory = genCats.reduce(\n    (o, k, i) => ({ ...o, [k]: mainCatsCount[i] }),\n    {}\n  );\n\n  return mainCategory;\n}\n\n//function to return phone records obejct in\n//a card taking into account NA\nexport function cardPhoneTextFilter(record) {\n  if (record.phone.length > 0) {\n    const cleanPhone = record.phone.map((phoneRecord) => {\n      const phone1 = phoneRecord.phone;\n      const phone2 = naRemove(phoneRecord.phone2);\n      //return the new object\n      return {\n        type: phoneRecord.type,\n        phone: phone1 + phone2,\n      };\n    });\n    return cleanPhone;\n  } else {\n    return null;\n  }\n}\n\nexport function cardTextFilter(recordKey) {\n  return naRemove(recordKey).trim();\n}\n\nexport function cardWebAddressFixer(webAddress) {\n  // if(address.indexOf(\"http\") > 0)\n  const webAddressFilter = cardTextFilter(webAddress);\n  if (webAddress.indexOf(\"http\") < 0 && webAddressFilter !== \"\") {\n    return `http://${webAddressFilter}`;\n  }\n  return webAddressFilter;\n}\n\n//function to build the map data object\nexport function mapDataBuilder(nodeData) {\n  const mapData = nodeData.map((record) => {\n    if (record.lat !== \"NA\") {\n      const coords = [Number(record.lat), Number(record.lon)];\n      const { listing, street, street2, hours, id } = record;\n      return {\n        coords,\n        popup: {\n          listing,\n          street,\n          street2: cardTextFilter(street2),\n          hours: cardTextFilter(hours),\n          id,\n        },\n      };\n    }\n  });\n\n  const mapDataFilter = mapData.filter((el) => el !== undefined);\n\n  const latArr = mapDataFilter.map((item) => item.coords[0]);\n  const lonArr = mapDataFilter.map((item) => item.coords[1]);\n  //now use the getCenter() helper function\n  const center = getCenter(latArr, lonArr, [45.52345, -122.6762]);\n\n  return { mapData: mapDataFilter, center };\n}\n\nexport function cardDetailsFilter(nodeData, savedIds) {\n  function exists(rec) {\n    return savedIds.indexOf(rec.id) > -1;\n  }\n\n  const filteredDetailsData = nodeData.filter(exists);\n  return filteredDetailsData;\n}\n\n// NON-EXPORTED HELPER UTILS-------------------------------------------------------\n//helper function for buildings the direction string\nfunction stringBuilder(str) {\n  return str.split(\" \").join(\"+\");\n}\n\n//helper function to build directions for google\nexport function directionsUrlBuilder(street, city, postal_code) {\n  if (street !== \"NA\") {\n    return `/${stringBuilder(street)}+${stringBuilder(city)}+${stringBuilder(\n      postal_code\n    )}`;\n  } else {\n    return \"NA\";\n  }\n}\n\n//helper function to get the center of a map\n//use this in the mapDatabuilder function\nfunction getCenter(latArr, lonArr, defaultArr) {\n  const average = (arr) => arr.reduce((p, c) => p + c, 0) / arr.length;\n  const lat = average(latArr);\n  const lon = average(lonArr);\n\n  if (isNaN(lat)) return defaultArr;\n  return [lat, lon];\n}\n\n//check if parent or category vals in records\n//helper for getFilteredNodeData\nfunction getFilteredCatParentData(categoryVals, parentVals, nodeData) {\n  const checkVals = [\n    // ...handleArray(searchVals),\n    ...handleArray(categoryVals),\n    ...handleArray(parentVals),\n  ].filter((el) => el !== null);\n\n  const filteredNodeData = nodeData.filter((record) => {\n    //create another array to see if checkVals are in\n    //the nodeVals\n    const nodeVals = [\n      record.listing,\n      record.parent_organization,\n      record.main_category,\n      record.general_category,\n    ];\n    //check to see if any values in one array are in the other array\n    //and if so return the record\n    if (nodeVals.some((item) => checkVals.indexOf(item) >= 0)) {\n      record.directionsUrl = directionsUrlBuilder(\n        record.street,\n        record.city,\n        record.postal_code\n      );\n      return record;\n    } else {\n      return null;\n    }\n  });\n  //filter out the nulls\n  return filteredNodeData.filter((el) => el !== null);\n}\n\n//check if a search value is in the NODE record\n//this function is gonna be used for individual searches\n//helper for getFilteredNodeData\nfunction getFilteredSearchData(searchValue, nodeData) {\n  //Polyfill from SO to use toLowerCase()\n  if (!String.toLowerCase) {\n    String.toLowerCase = function (s) {\n      return String(s).toLowerCase();\n    };\n  }\n\n  const filterData = nodeData.map((record) => {\n    const recordValsLower = Object.values(record).map(\n      (val) => {\n        return String(val).toLowerCase();\n      } //I miss R\n    );\n    if (recordValsLower.join(\" \").includes(String(searchValue).toLowerCase())) {\n      record.directionsUrl = directionsUrlBuilder(\n        record.street,\n        record.city,\n        record.postal_code\n      );\n      return record;\n    }\n  });\n  // remove the undefined els from the list\n  return filterData.filter((el) => el);\n}\n\n//function to deal with 'NA' values\n//and return an empty string instead\nfunction naRemove(str) {\n  if (str === \"NA\") return \"\";\n  return \" \" + str;\n}\n\n//function to join the phone data to the nodeData based on id\nfunction phonePositionJoiner(nodeData, phoneData, currentCoords) {\n  const nodePhoneData = nodeData.map((listRecord) => {\n    //filter out the phone records that relate to the nodeRecord\n    const phoneKeep = phoneData.filter((phoneRecord) => {\n      return phoneRecord.id === listRecord.id;\n    });\n\n    //calculate the distance here\n    const listCoords = [Number(listRecord.lat), Number(listRecord.lon)];\n    let distance;\n    //handle whether an array was returned\n    if (Array.isArray(currentCoords)) {\n      distance = findDistance(currentCoords, listCoords);\n    } else {\n      distance = null;\n    }\n    return Object.assign(listRecord, { phone: phoneKeep, distance: distance });\n  });\n  return nodePhoneData;\n}\n\n//count the duplicates in an array and\n//retrun an obect with the value and count\nfunction countDuplicates(arr) {\n  const map = arr.reduce(function (prev, cur) {\n    prev[cur] = (prev[cur] || 0) + 1;\n    return prev;\n  }, {});\n  return map;\n}\n\n//helper function to deal with the\n//parsing of query string\nfunction handleArray(item) {\n  if (item === undefined) return [null];\n  if (Array.isArray(item)) return item;\n  if (typeof item === \"string\") return [item];\n}\n\n//for async errors\n//this can be more expressive\nfunction handleError(error) {\n  console.warn(\"Something went wrong with a fetch.\", error);\n\n  return null;\n}\n\n// EXPORTED HELPER UTILS ----------------------------------------------\n\n//function to generate query\n//for detaisl page\nexport function detailsQueryBuilder(savedIds) {\n  // if(savedIds.length===0){\n  //   alert('No saved listings.')\n  // }\n  const queryDetailString = savedIds.join(\"&saved=\");\n  return `saved=${queryDetailString}`;\n}\n\n//get the object keys based on value\nexport function objectKeyByValue(obj, val) {\n  return Object.entries(obj).find((i) => i[1] === val);\n}\n\n//make a query builder that will be passed to react router\n//parameter expect an array\nexport function queryBuilder(categoryVals, parentVals) {\n  let categoryString = \"\";\n  let parentString = \"\";\n\n  for (let i = 0; i < categoryVals.length; i++) {\n    categoryString += `category=${encodeURIComponent(categoryVals[i])}&`;\n  }\n\n  for (let i = 0; i < parentVals.length; i++) {\n    parentString += `parent=${encodeURIComponent(parentVals[i])}&`;\n  }\n\n  const queryString = `?${categoryString}${parentString}`;\n  return queryString;\n}\n\n//sort the cards based on the retirned distance\nexport function cardSortByDistance(data) {\n  function compare(a, b) {\n    a = a[\"distance\"];\n    b = b[\"distance\"];\n    if (isFinite(a - b)) {\n      return a - b;\n    } else {\n      return isFinite(a) ? -1 : 1; // switch these to retrun NaN at top\n    }\n  }\n  return data.sort(compare);\n}\n\n// --------------------------------------------------------------------------\n// ----------------------------------------------------------------------------\n// --END USED FUNCTION UTILS----------------------------------------------------\n\n//UNUSED ASYNC DATA UTILS--------------------------------------------------------\n\n//fetching utils\n// export async function getSearchData(searchCats) {\n//   const searchList = searchCats.join(\" ,\");\n\n//   const uri = `https://opendata.imspdx.org/api/3/action/datastore_search_sql?sql=SELECT ${searchList} from \"${listingResource}\"`;\n//   const searchData = await fetch(uri)\n//     .then((response) => response.json())\n//     .then((json) => json.result.records)\n//     .catch(handleError);\n\n//   const filteredValsList = searchData.map((record) => {\n//     return searchCats.map((cat) => record[cat]);\n//   });\n//   const catList = [].concat(...filteredValsList);\n//   return [...new Set(catList)].sort();\n// }\n\n// //\n// export async function getSelectedCategories(navCategory, selectedItem) {\n//   if (selectedItem === null) {\n//     const dataResponse = await fetch(\n//       `https://opendata.imspdx.org/api/3/action/datastore_search_sql?sql=SELECT general_category from \"${listingResource}\"`\n//     ).catch(handleError);\n\n//     const jsonDataArr = await dataResponse\n//       .json()\n//       .then((json) => json.result.records)\n//       .then((records) => {\n//         return records.map((record) => Object.values(record));\n//       });\n\n//     const jsonDataCount = await countDuplicates(jsonDataArr);\n//     // console.log('jsonDataCount', jsonDataCount);\n//     return jsonDataCount;\n//   } else {\n//     const cleanSelectedItem = selectedItem.replace(\"&\", \"%26\");\n//     const uri = `https://opendata.imspdx.org/api/3/action/datastore_search_sql?sql=SELECT main_category from \"${listingResource}\" WHERE ${navCategory} LIKE '${cleanSelectedItem}'`;\n\n//     const dataResponse = await fetch(uri).catch(handleError);\n\n//     const jsonDataArr = await dataResponse\n//       .json()\n//       .then((json) => json.result.records)\n//       .then((records) => {\n//         return records.map((record) => Object.values(record));\n//       });\n\n//     const jsonDataCount = await countDuplicates(jsonDataArr);\n//     return jsonDataCount;\n//   }\n// }\n\n// //build the query from results of search\n// //include helper functions which are below\n// export async function nodeQueryBuilder(catVals, parentVals, searchVals = []) {\n//   //return a null is both values are undefined\n//   //this can likely be handled in the adv search\n//   if (catVals === undefined && parentVals === undefined) {\n//     return null;\n//   } else {\n//     const categoryString = queryStringBuilder(catVals, \"main\");\n//     const parentString = queryStringBuilder(parentVals, \"parent\");\n\n//     //put the URI together, this can be further split\n//     const uri = `https://opendata.imspdx.org/api/3/action/datastore_search_sql?sql=SELECT * from \"${listingResource}\" WHERE ${categoryString} OR ${parentString}`;\n\n//     const response = await fetch(uri).catch(handleError);\n\n//     const jsonDataArr = await response\n//       .json()\n//       .then((json) => json.result.records)\n//       .then((records) => records);\n\n//     return jsonDataArr;\n//   }\n// }\n\n// UNUSED SYNC DATA UTILS ------------------------------------------------\n\n//////data utils for switching categories\n// export function categoryFwdSwitcher(category) {\n//   if (category === \"general_category\") {\n//     return \"main_category\";\n//   }\n// }\n\n// export function categoryBackSwitcher(category) {\n//   if (category === \"main_category\") {\n//     return \"general_category\";\n//   }\n//   if (category === \"general_category\") {\n//     return null;\n//   }\n// }\n\n// UNUSED HELPER UTILS-----------------------------------------------------------\n\n//helper function\n//build the string while expecting an array\n//deal with category type and\n// function queryStringBuilder(arrItem, category) {\n//   //sanitize the arrItem\n//   const arr = handleArray(arrItem);\n\n//   if (category === \"main\") {\n//     if (arr !== null) {\n//       const categoryString = arr\n//         .map((val) => {\n//           const encodeUri = encodeURIComponent(val);\n//           return `'${encodeUri}'`;\n//         })\n//         .join(\"OR main_category LIKE \");\n\n//       return `main_category LIKE ${categoryString}`;\n//     } else {\n//       return null;\n//     }\n//   }\n\n//   if (category === \"parent\") {\n//     if (arr !== null) {\n//       const parentString = arr\n//         .map((val) => {\n//           const encodeUri = encodeURIComponent(val);\n//           return `'${encodeUri}'`;\n//         })\n//         .join(\"OR parent_organization LIKE \");\n\n//       return `parent_organization LIKE ${parentString}`;\n//     }\n//     return null;\n//   }\n// }\n\n// UNUSED PROP TYPE UTILS---------------------------------------------------\n\n//prop-types helpers\n// export function conditionalPropType(condition, message) {\n//   if (typeof condition !== \"function\")\n//     throw \"Wrong argument type 'condition' supplied to 'conditionalPropType'\";\n//   return function (props, propName, componentName) {\n//     if (condition(props, propName, componentName)) {\n//       return new Error(\n//         `Invalid prop '${propName}' '${props[propName]}' supplied to '${componentName}'. ${message}`\n//       );\n//     }\n//   };\n// }\n\n//More async funtions that interact with NODE\n// export async function getCategoryList(navCategory) {\n//   const uri = `https://opendata.imspdx.org/api/3/action/datastore_search_sql?sql=SELECT  from \"${listingResource}\" WHERE 'main_category' LIKE ${navCategory}`;\n//   const categories = await fetch(uri);\n//   return categories;\n// }\n\n////////////////////////////////////////////////////IN DEV\n// export async function getSearchList(searchCats) {\n//   //if needed in dev, here is a proxy\n//   const proxy = 'https://cors-anywhere.herokuapp.com/';\n\n//   //categories to include in the initial searching\n//   const searchCatsUri = searchCats.join(', ');\n//   const uri = `https://opendata.imspdx.org/api/3/action/datastore_search_sql?sql=SELECT ${searchCatsUri} from \"${listingResource}\"`;\n//   const searchData = await fetch(uri)\n//     .then(response => response.json())\n//     .then(json => json.result.records)\n//     //select out the values only\n//     .then(records => {\n//       return records.map(record => Object.values(record));\n//     })\n//     //concatenate lists and filter duplicates\n//     .then(lists => {\n//       const catList = [].concat.apply([], lists);\n//       return [...new Set(catList)].sort();\n//     });\n//   //return the final filtered list\n//   return searchData;\n// }\n\n///////////////////////////////////////////\n// return a list with full NODE data and filtered list for search bar\n// export async function getFilteredSearchList(searchCats) {\n//   let nodeData;\n//   const searchData = await getNodeData()\n//     .then(json => {\n//       nodeData = json.result.records;\n//       return nodeData;\n//     })\n//     .then(records => {\n//       const filteredValsList = records.map(record => {\n//         return searchCats.map(cat => record[cat]);\n//       });\n//       return filteredValsList;\n//     })\n//     .then(searchList => {\n//       const catList = [].concat(...searchList);\n//       return [...new Set(catList)].sort();\n//     });\n//   return [nodeData, searchData];\n// }\n/////////////////////////////////\n// export function getCategorySearchData(nodeData) {\n//   const categories = nodeData.map(record => {\n//     const generalVal = record['general_category'];\n//     const mainVal = record['main_category'];\n//     return { generalVal, mainVal };\n//   });\n\n//   return categories;\n// }\n"]},"metadata":{},"sourceType":"module"}